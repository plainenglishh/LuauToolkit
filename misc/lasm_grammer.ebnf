(* non-terminals, grouped by AST node *)

chunk = {chunk_attribute | string_def | proto_def | alias_def};

string_def = STRING_KEYWORD IDENTIFIER EQ STRING_LITERAL SEMICOLON;

proto_def = proto_header {proto_body} END_KEYWORD;
proto_header = {proto_attribute} PROTO_KEYWORD IDENTIFIER OPEN_PAREN [literal] {COMMA literal} CLOSE_PAREN;
proto_body = {instruction | alias_def | const_def};

instruction = [label] IDENTIFIER [value] {COMMA value} SEMICOLON;
label = IDENTIFIER COLON;

alias_def = ALIAS_KEYWORD IDENTIFIER EQ value SEMICOLON;

const_def = CONST_KEYWORD IDENTIFIER EQ value SEMICOLON;

proto_attribute = AT attribute_body;
chunk_attribute = AT EXCLAIM attribute_body;
attribute_body = IDENTIFIER | OPEN_SBRACKET IDENTIFIER [EQ literal] CLOSE_SBRACKET;

value = identifier | literal;

literal = NIL_LITERAL | BOOLEAN_LITERAL | STRING_LITERAL | NUMBER_LITERAL | VECTOR_LITERAL | IMPORT_LITERAL;

identifier = IDENTIFIER; (* For when identifier should be emitted as an AST node instead of a string literal *)


(* Tokens *)

IMPORT_LITERAL = ENV_KEYWORD '.' IDENTIFIER ['.' IDENTIFIER];
VECTOR_LITERAL = '<' [NUMBER_LITERAL] [COMMA NUMBER_LITERAL] [COMMA NUMBER_LITERAL] [COMMA NUMBER_LITERAL]'>';
NUMBER_LITERAL = (('0x'|'0X') ? any digit or underscore ?) | (('0b'|'0B') ? any digit or underscore ?) | (? any digit or underscore ? '.' ? any digit or underscore ?);
STRING_LITERAL = '"' ? any character ? '"';
BOOLEAN_LITERAL = 'true' | 'false';
NIL_LITERAL = 'nil';

PROTO_KEYWORD = 'proto';
ALIAS_KEYWORD = 'alias';
CONST_KEYWORD = 'const';
STRING_KEYWORD = 'string';
END_KEYWORD = 'end';
ENV_KEYWORD = 'env';

IDENTIFIER = ? any letter, or '_' ? {? any letter, digit or '_' ?};

OPEN_PAREN = '(';
CLOSE_PAREN = ')';
OPEN_SBRACKET = '[';
CLOSE_SBRACKET = ']';
AT = '@';
EXCLAIM = '!';
EQ = '=';
SEMICOLON = ';';
COLON = ':';
DOT = '.';
COMMA = ',';

COMMENT = '--' ? any character except newline ? NEWLINE; (* Should NOT be emitted*)