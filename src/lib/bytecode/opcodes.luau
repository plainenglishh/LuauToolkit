-- This file is autogenerated, see scripts/update_opcodes.luau

export type OperandName = "a" | "b" | "c" | "d" | "e" | "aux";
export type OperandMode = "abc" | "ad" | "e" | "none";
export type OperandType = "register" | "jump_offset" | "constant" | "proto" | "number"; 

export type OperandInfo = {
    name: string,
    type: {OperandType},
    description: string,
};

export type OpcodeInfo = {
    name: string,
    opcode: number,
    mode: OperandMode,
    aux: boolean,
    description: string,
    operands: {OperandInfo},
    size: number,
};

export type OpcodeName =
    | "NOP"                  | "BREAK"                | "LOADNIL"             
    | "LOADB"                | "LOADN"                | "LOADK"               
    | "MOVE"                 | "GETGLOBAL"            | "SETGLOBAL"           
    | "GETUPVAL"             | "SETUPVAL"             | "CLOSEUPVALS"         
    | "GETIMPORT"            | "GETTABLE"             | "SETTABLE"            
    | "GETTABLEKS"           | "SETTABLEKS"           | "GETTABLEN"           
    | "SETTABLEN"            | "NEWCLOSURE"           | "NAMECALL"            
    | "CALL"                 | "RETURN"               | "JUMP"                
    | "JUMPBACK"             | "JUMPIF"               | "JUMPIFNOT"           
    | "JUMPIFEQ"             | "JUMPIFLE"             | "JUMPIFLT"            
    | "JUMPIFNOTEQ"          | "JUMPIFNOTLE"          | "JUMPIFNOTLT"         
    | "ADD"                  | "SUB"                  | "MUL"                 
    | "DIV"                  | "MOD"                  | "POW"                 
    | "ADDK"                 | "SUBK"                 | "MULK"                
    | "DIVK"                 | "MODK"                 | "POWK"                
    | "AND"                  | "OR"                   | "ANDK"                
    | "ORK"                  | "CONCAT"               | "NOT"                 
    | "MINUS"                | "LENGTH"               | "NEWTABLE"            
    | "DUPTABLE"             | "SETLIST"              | "FORNPREP"            
    | "FORNLOOP"             | "FORGLOOP"             | "FORGPREP_INEXT"      
    | "FASTCALL3"            | "FORGPREP_NEXT"        | "NATIVECALL"          
    | "GETVARARGS"           | "DUPCLOSURE"           | "PREPVARARGS"         
    | "LOADKX"               | "JUMPX"                | "FASTCALL"            
    | "COVERAGE"             | "CAPTURE"              | "SUBRK"               
    | "DIVRK"                | "FASTCALL1"            | "FASTCALL2"           
    | "FASTCALL2K"           | "FORGPREP"             | "JUMPXEQKNIL"         
    | "JUMPXEQKB"            | "JUMPXEQKN"            | "JUMPXEQKS"           
    | "IDIV"                 | "IDIVK"                ;

local opcodes: {[number]: OpcodeInfo} = {
    --[=[
        NOP: noop
    ]=]
    [0] = {
        name = "NOP",
        opcode = 0,
        mode = "none",
        aux = false,
        description = "noop",
        operands = {},
        size = 1,
    },

    --[=[
        BREAK: debugger break
    ]=]
    [1] = {
        name = "BREAK",
        opcode = 1,
        mode = "none",
        aux = false,
        description = "debugger break",
        operands = {},
        size = 1,
    },

    --[=[
        LOADNIL: sets register to nil
    ]=]
    [2] = {
        name = "LOADNIL",
        opcode = 2,
        mode = "abc",
        aux = false,
        description = "sets register to nil",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },
        },
        size = 1,
    },

    --[=[
        LOADB: sets register to boolean and jumps to a given short offset (used to compile comparison results into a boolean)
    ]=]
    [3] = {
        name = "LOADB",
        opcode = 3,
        mode = "abc",
        aux = false,
        description = "sets register to boolean and jumps to a given short offset (used to compile comparison results into a boolean)",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: value (0/1)
            { name = "b", type = {"number"}, description = "value (0/1)" },

            --- C: jump offset
            { name = "c", type = {"jump_offset"}, description = "jump offset" },
        },
        size = 1,
    },

    --[=[
        LOADN: sets register to a number literal
    ]=]
    [4] = {
        name = "LOADN",
        opcode = 4,
        mode = "ad",
        aux = false,
        description = "sets register to a number literal",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- D: value (-32768..32767)
            { name = "d", type = {"number"}, description = "value (-32768..32767)" },
        },
        size = 1,
    },

    --[=[
        LOADK: sets register to an entry from the constant table from the proto (number/vector/string)
    ]=]
    [5] = {
        name = "LOADK",
        opcode = 5,
        mode = "ad",
        aux = false,
        description = "sets register to an entry from the constant table from the proto (number/vector/string)",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- D: constant table index (0..32767)
            { name = "d", type = {"constant"}, description = "constant table index (0..32767)" },
        },
        size = 1,
    },

    --[=[
        MOVE: move (copy) value from one register to another
    ]=]
    [6] = {
        name = "MOVE",
        opcode = 6,
        mode = "abc",
        aux = false,
        description = "move (copy) value from one register to another",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },
        },
        size = 1,
    },

    --[=[
        GETGLOBAL: load value from global table using constant string as a key
    ]=]
    [7] = {
        name = "GETGLOBAL",
        opcode = 7,
        mode = "abc",
        aux = true,
        description = "load value from global table using constant string as a key",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- C: predicted slot index (based on hash)
            { name = "c", type = {"number"}, description = "predicted slot index (based on hash)" },

            --- AUX: constant table index
            { name = "aux", type = {"constant"}, description = "constant table index" },
        },
        size = 2,
    },

    --[=[
        SETGLOBAL: set value in global table using constant string as a key
    ]=]
    [8] = {
        name = "SETGLOBAL",
        opcode = 8,
        mode = "abc",
        aux = true,
        description = "set value in global table using constant string as a key",
        operands = {
            --- A: source register
            { name = "a", type = {"register"}, description = "source register" },

            --- C: predicted slot index (based on hash)
            { name = "c", type = {"number"}, description = "predicted slot index (based on hash)" },

            --- AUX: constant table index
            { name = "aux", type = {"constant"}, description = "constant table index" },
        },
        size = 2,
    },

    --[=[
        GETUPVAL: load upvalue from the upvalue table for the current function
    ]=]
    [9] = {
        name = "GETUPVAL",
        opcode = 9,
        mode = "abc",
        aux = false,
        description = "load upvalue from the upvalue table for the current function",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: upvalue index
            { name = "b", type = {"number"}, description = "upvalue index" },
        },
        size = 1,
    },

    --[=[
        SETUPVAL: store value into the upvalue table for the current function
    ]=]
    [10] = {
        name = "SETUPVAL",
        opcode = 10,
        mode = "abc",
        aux = false,
        description = "store value into the upvalue table for the current function",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: upvalue index
            { name = "b", type = {"number"}, description = "upvalue index" },
        },
        size = 1,
    },

    --[=[
        CLOSEUPVALS: close (migrate to heap) all upvalues that were captured for registers >= target
    ]=]
    [11] = {
        name = "CLOSEUPVALS",
        opcode = 11,
        mode = "abc",
        aux = false,
        description = "close (migrate to heap) all upvalues that were captured for registers >= target",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },
        },
        size = 1,
    },

    --[=[
        GETIMPORT: load imported global table global from the constant table
    ]=]
    [12] = {
        name = "GETIMPORT",
        opcode = 12,
        mode = "ad",
        aux = true,
        description = "load imported global table global from the constant table",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- D: constant table index (0..32767); we assume that imports are loaded into the constant table
            { name = "d", type = {"constant"}, description = "constant table index (0..32767); we assume that imports are loaded into the constant table" },

            --- AUX: 3 10-bit indices of constant strings that, combined, constitute an import path; length of the path is set by the top 2 bits (1,2,3)
            { name = "aux", type = {"constant"}, description = "3 10-bit indices of constant strings that, combined, constitute an import path; length of the path is set by the top 2 bits (1,2,3)" },
        },
        size = 2,
    },

    --[=[
        GETTABLE: load value from table into target register using key from register
    ]=]
    [13] = {
        name = "GETTABLE",
        opcode = 13,
        mode = "abc",
        aux = false,
        description = "load value from table into target register using key from register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: table register
            { name = "b", type = {"register"}, description = "table register" },

            --- C: index register
            { name = "c", type = {"register"}, description = "index register" },
        },
        size = 1,
    },

    --[=[
        SETTABLE: store source register into table using key from register
    ]=]
    [14] = {
        name = "SETTABLE",
        opcode = 14,
        mode = "abc",
        aux = false,
        description = "store source register into table using key from register",
        operands = {
            --- A: source register
            { name = "a", type = {"register"}, description = "source register" },

            --- B: table register
            { name = "b", type = {"register"}, description = "table register" },

            --- C: index register
            { name = "c", type = {"register"}, description = "index register" },
        },
        size = 1,
    },

    --[=[
        GETTABLEKS: load value from table into target register using constant string as a key
    ]=]
    [15] = {
        name = "GETTABLEKS",
        opcode = 15,
        mode = "abc",
        aux = true,
        description = "load value from table into target register using constant string as a key",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: table register
            { name = "b", type = {"register"}, description = "table register" },

            --- C: predicted slot index (based on hash)
            { name = "c", type = {"number"}, description = "predicted slot index (based on hash)" },

            --- AUX: constant table index
            { name = "aux", type = {"constant"}, description = "constant table index" },
        },
        size = 2,
    },

    --[=[
        SETTABLEKS: store source register into table using constant string as a key
    ]=]
    [16] = {
        name = "SETTABLEKS",
        opcode = 16,
        mode = "abc",
        aux = true,
        description = "store source register into table using constant string as a key",
        operands = {
            --- A: source register
            { name = "a", type = {"register"}, description = "source register" },

            --- B: table register
            { name = "b", type = {"register"}, description = "table register" },

            --- C: predicted slot index (based on hash)
            { name = "c", type = {"number"}, description = "predicted slot index (based on hash)" },

            --- AUX: constant table index
            { name = "aux", type = {"constant"}, description = "constant table index" },
        },
        size = 2,
    },

    --[=[
        GETTABLEN: load value from table into target register using small integer index as a key
    ]=]
    [17] = {
        name = "GETTABLEN",
        opcode = 17,
        mode = "abc",
        aux = false,
        description = "load value from table into target register using small integer index as a key",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: table register
            { name = "b", type = {"register"}, description = "table register" },

            --- C: index-1 (index is 1..256)
            { name = "c", type = {"number"}, description = "index-1 (index is 1..256)" },
        },
        size = 1,
    },

    --[=[
        SETTABLEN: store source register into table using small integer index as a key
    ]=]
    [18] = {
        name = "SETTABLEN",
        opcode = 18,
        mode = "abc",
        aux = false,
        description = "store source register into table using small integer index as a key",
        operands = {
            --- A: source register
            { name = "a", type = {"register"}, description = "source register" },

            --- B: table register
            { name = "b", type = {"register"}, description = "table register" },

            --- C: index-1 (index is 1..256)
            { name = "c", type = {"number"}, description = "index-1 (index is 1..256)" },
        },
        size = 1,
    },

    --[=[
        NEWCLOSURE: create closure from a child proto; followed by a CAPTURE instruction for each upvalue
    ]=]
    [19] = {
        name = "NEWCLOSURE",
        opcode = 19,
        mode = "ad",
        aux = false,
        description = "create closure from a child proto; followed by a CAPTURE instruction for each upvalue",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- D: child proto index (0..32767)
            { name = "d", type = {"proto"}, description = "child proto index (0..32767)" },
        },
        size = 1,
    },

    --[=[
        NAMECALL: prepare to call specified method by name by loading function from source register using constant index into target register and copying source register into target register + 1
        Note that this instruction must be followed directly by CALL; it prepares the arguments
        This instruction is roughly equivalent to GETTABLEKS + MOVE pair, but we need a special instruction to support custom __namecall metamethod
    ]=]
    [20] = {
        name = "NAMECALL",
        opcode = 20,
        mode = "abc",
        aux = true,
        description = "prepare to call specified method by name by loading function from source register using constant index into target register and copying source register into target register + 1\nNote that this instruction must be followed directly by CALL; it prepares the arguments\nThis instruction is roughly equivalent to GETTABLEKS + MOVE pair, but we need a special instruction to support custom __namecall metamethod",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: predicted slot index (based on hash)
            { name = "c", type = {"number"}, description = "predicted slot index (based on hash)" },

            --- AUX: constant table index
            { name = "aux", type = {"constant"}, description = "constant table index" },
        },
        size = 2,
    },

    --[=[
        CALL: call specified function
    ]=]
    [21] = {
        name = "CALL",
        opcode = 21,
        mode = "abc",
        aux = false,
        description = "call specified function",
        operands = {
            --- A: register where the function object lives, followed by arguments; results are placed starting from the same register
            { name = "a", type = {"register"}, description = "register where the function object lives, followed by arguments; results are placed starting from the same register" },

            --- B: argument count + 1, or 0 to preserve all arguments up to top (MULTRET)
            { name = "b", type = {"number"}, description = "argument count + 1, or 0 to preserve all arguments up to top (MULTRET)" },

            --- C: result count + 1, or 0 to preserve all values and adjust top (MULTRET)
            { name = "c", type = {"number"}, description = "result count + 1, or 0 to preserve all values and adjust top (MULTRET)" },
        },
        size = 1,
    },

    --[=[
        RETURN: returns specified values from the function
    ]=]
    [22] = {
        name = "RETURN",
        opcode = 22,
        mode = "abc",
        aux = false,
        description = "returns specified values from the function",
        operands = {
            --- A: register where the returned values start
            { name = "a", type = {"register"}, description = "register where the returned values start" },

            --- B: number of returned values + 1, or 0 to return all values up to top (MULTRET)
            { name = "b", type = {"number"}, description = "number of returned values + 1, or 0 to return all values up to top (MULTRET)" },
        },
        size = 1,
    },

    --[=[
        JUMP: jumps to target offset
    ]=]
    [23] = {
        name = "JUMP",
        opcode = 23,
        mode = "ad",
        aux = false,
        description = "jumps to target offset",
        operands = {
            --- D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 0 means \"next instruction\" aka \"don't jump\")" },
        },
        size = 1,
    },

    --[=[
        JUMPBACK: jumps to target offset; this is equivalent to JUMP but is used as a safepoint to be able to interrupt while/repeat loops
    ]=]
    [24] = {
        name = "JUMPBACK",
        opcode = 24,
        mode = "ad",
        aux = false,
        description = "jumps to target offset; this is equivalent to JUMP but is used as a safepoint to be able to interrupt while/repeat loops",
        operands = {
            --- D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 0 means \"next instruction\" aka \"don't jump\")" },
        },
        size = 1,
    },

    --[=[
        JUMPIF: jumps to target offset if register is not nil/false
    ]=]
    [25] = {
        name = "JUMPIF",
        opcode = 25,
        mode = "ad",
        aux = false,
        description = "jumps to target offset if register is not nil/false",
        operands = {
            --- A: source register
            { name = "a", type = {"register"}, description = "source register" },

            --- D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 0 means \"next instruction\" aka \"don't jump\")" },
        },
        size = 1,
    },

    --[=[
        JUMPIFNOT: jumps to target offset if register is nil/false
    ]=]
    [26] = {
        name = "JUMPIFNOT",
        opcode = 26,
        mode = "ad",
        aux = false,
        description = "jumps to target offset if register is nil/false",
        operands = {
            --- A: source register
            { name = "a", type = {"register"}, description = "source register" },

            --- D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 0 means \"next instruction\" aka \"don't jump\")" },
        },
        size = 1,
    },

    --[=[
        JUMPIFEQ: jumps to target offset if the comparison is true (or false, for NOT variants)
    ]=]
    [27] = {
        name = "JUMPIFEQ",
        opcode = 27,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison is true (or false, for NOT variants)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: source register 2
            { name = "aux", type = {"register"}, description = "source register 2" },
        },
        size = 2,
    },

    --[=[
        JUMPIFLE: jumps to target offset if the comparison is true (or false, for NOT variants)
    ]=]
    [28] = {
        name = "JUMPIFLE",
        opcode = 28,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison is true (or false, for NOT variants)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: source register 2
            { name = "aux", type = {"register"}, description = "source register 2" },
        },
        size = 2,
    },

    --[=[
        JUMPIFLT: jumps to target offset if the comparison is true (or false, for NOT variants)
    ]=]
    [29] = {
        name = "JUMPIFLT",
        opcode = 29,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison is true (or false, for NOT variants)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: source register 2
            { name = "aux", type = {"register"}, description = "source register 2" },
        },
        size = 2,
    },

    --[=[
        JUMPIFNOTEQ: jumps to target offset if the comparison is true (or false, for NOT variants)
    ]=]
    [30] = {
        name = "JUMPIFNOTEQ",
        opcode = 30,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison is true (or false, for NOT variants)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: source register 2
            { name = "aux", type = {"register"}, description = "source register 2" },
        },
        size = 2,
    },

    --[=[
        JUMPIFNOTLE: jumps to target offset if the comparison is true (or false, for NOT variants)
    ]=]
    [31] = {
        name = "JUMPIFNOTLE",
        opcode = 31,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison is true (or false, for NOT variants)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: source register 2
            { name = "aux", type = {"register"}, description = "source register 2" },
        },
        size = 2,
    },

    --[=[
        JUMPIFNOTLT: jumps to target offset if the comparison is true (or false, for NOT variants)
    ]=]
    [32] = {
        name = "JUMPIFNOTLT",
        opcode = 32,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison is true (or false, for NOT variants)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: source register 2
            { name = "aux", type = {"register"}, description = "source register 2" },
        },
        size = 2,
    },

    --[=[
        ADD: compute arithmetic operation between two source registers and put the result into target register
    ]=]
    [33] = {
        name = "ADD",
        opcode = 33,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        SUB: compute arithmetic operation between two source registers and put the result into target register
    ]=]
    [34] = {
        name = "SUB",
        opcode = 34,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        MUL: compute arithmetic operation between two source registers and put the result into target register
    ]=]
    [35] = {
        name = "MUL",
        opcode = 35,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        DIV: compute arithmetic operation between two source registers and put the result into target register
    ]=]
    [36] = {
        name = "DIV",
        opcode = 36,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        MOD: compute arithmetic operation between two source registers and put the result into target register
    ]=]
    [37] = {
        name = "MOD",
        opcode = 37,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        POW: compute arithmetic operation between two source registers and put the result into target register
    ]=]
    [38] = {
        name = "POW",
        opcode = 38,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        ADDK: compute arithmetic operation between the source register and a constant and put the result into target register
    ]=]
    [39] = {
        name = "ADDK",
        opcode = 39,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255); must refer to a number
            { name = "c", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },
        },
        size = 1,
    },

    --[=[
        SUBK: compute arithmetic operation between the source register and a constant and put the result into target register
    ]=]
    [40] = {
        name = "SUBK",
        opcode = 40,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255); must refer to a number
            { name = "c", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },
        },
        size = 1,
    },

    --[=[
        MULK: compute arithmetic operation between the source register and a constant and put the result into target register
    ]=]
    [41] = {
        name = "MULK",
        opcode = 41,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255); must refer to a number
            { name = "c", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },
        },
        size = 1,
    },

    --[=[
        DIVK: compute arithmetic operation between the source register and a constant and put the result into target register
    ]=]
    [42] = {
        name = "DIVK",
        opcode = 42,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255); must refer to a number
            { name = "c", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },
        },
        size = 1,
    },

    --[=[
        MODK: compute arithmetic operation between the source register and a constant and put the result into target register
    ]=]
    [43] = {
        name = "MODK",
        opcode = 43,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255); must refer to a number
            { name = "c", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },
        },
        size = 1,
    },

    --[=[
        POWK: compute arithmetic operation between the source register and a constant and put the result into target register
    ]=]
    [44] = {
        name = "POWK",
        opcode = 44,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255); must refer to a number
            { name = "c", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },
        },
        size = 1,
    },

    --[=[
        AND: perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register
    ]=]
    [45] = {
        name = "AND",
        opcode = 45,
        mode = "abc",
        aux = false,
        description = "perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        OR: perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register
    ]=]
    [46] = {
        name = "OR",
        opcode = 46,
        mode = "abc",
        aux = false,
        description = "perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        ANDK: perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register
    ]=]
    [47] = {
        name = "ANDK",
        opcode = 47,
        mode = "abc",
        aux = false,
        description = "perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255)
            { name = "c", type = {"constant"}, description = "constant table index (0..255)" },
        },
        size = 1,
    },

    --[=[
        ORK: perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register
    ]=]
    [48] = {
        name = "ORK",
        opcode = 48,
        mode = "abc",
        aux = false,
        description = "perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255)
            { name = "c", type = {"constant"}, description = "constant table index (0..255)" },
        },
        size = 1,
    },

    --[=[
        CONCAT: concatenate all strings between B and C (inclusive) and put the result into A
    ]=]
    [49] = {
        name = "CONCAT",
        opcode = 49,
        mode = "abc",
        aux = false,
        description = "concatenate all strings between B and C (inclusive) and put the result into A",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register start
            { name = "b", type = {"register"}, description = "source register start" },

            --- C: source register end
            { name = "c", type = {"register"}, description = "source register end" },
        },
        size = 1,
    },

    --[=[
        NOT: compute unary operation for source register and put the result into target register
    ]=]
    [50] = {
        name = "NOT",
        opcode = 50,
        mode = "abc",
        aux = false,
        description = "compute unary operation for source register and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },
        },
        size = 1,
    },

    --[=[
        MINUS: compute unary operation for source register and put the result into target register
    ]=]
    [51] = {
        name = "MINUS",
        opcode = 51,
        mode = "abc",
        aux = false,
        description = "compute unary operation for source register and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },
        },
        size = 1,
    },

    --[=[
        LENGTH: compute unary operation for source register and put the result into target register
    ]=]
    [52] = {
        name = "LENGTH",
        opcode = 52,
        mode = "abc",
        aux = false,
        description = "compute unary operation for source register and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },
        },
        size = 1,
    },

    --[=[
        NEWTABLE: create table in target register
    ]=]
    [53] = {
        name = "NEWTABLE",
        opcode = 53,
        mode = "abc",
        aux = true,
        description = "create table in target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: table size, stored as 0 for v=0 and ceil(log2(v))+1 for v!=0
            { name = "b", type = {"number"}, description = "table size, stored as 0 for v=0 and ceil(log2(v))+1 for v!=0" },

            --- AUX: array size
            { name = "aux", type = {"number"}, description = "array size" },
        },
        size = 2,
    },

    --[=[
        DUPTABLE: duplicate table using the constant table template to target register
    ]=]
    [54] = {
        name = "DUPTABLE",
        opcode = 54,
        mode = "ad",
        aux = false,
        description = "duplicate table using the constant table template to target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- D: constant table index (0..32767)
            { name = "d", type = {"constant"}, description = "constant table index (0..32767)" },
        },
        size = 1,
    },

    --[=[
        SETLIST: set a list of values to table in target register
    ]=]
    [55] = {
        name = "SETLIST",
        opcode = 55,
        mode = "abc",
        aux = true,
        description = "set a list of values to table in target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register start
            { name = "b", type = {"register"}, description = "source register start" },

            --- C: value count + 1, or 0 to use all values up to top (MULTRET)
            { name = "c", type = {"number"}, description = "value count + 1, or 0 to use all values up to top (MULTRET)" },

            --- AUX: table index to start from
            { name = "aux", type = {"number"}, description = "table index to start from" },
        },
        size = 2,
    },

    --[=[
        FORNPREP: prepare a numeric for loop, jump over the loop if first iteration doesn't need to run
        limit/step are immutable, index isn't visible to user code since it's copied into variable
    ]=]
    [56] = {
        name = "FORNPREP",
        opcode = 56,
        mode = "ad",
        aux = false,
        description = "prepare a numeric for loop, jump over the loop if first iteration doesn't need to run\nlimit/step are immutable, index isn't visible to user code since it's copied into variable",
        operands = {
            --- A: target register; numeric for loops assume a register layout [limit, step, index, variable]
            { name = "a", type = {"register"}, description = "target register; numeric for loops assume a register layout [limit, step, index, variable]" },

            --- D: jump offset (-32768..32767)
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767)" },
        },
        size = 1,
    },

    --[=[
        FORNLOOP: adjust loop variables for one iteration, jump back to the loop header if loop needs to continue
    ]=]
    [57] = {
        name = "FORNLOOP",
        opcode = 57,
        mode = "ad",
        aux = false,
        description = "adjust loop variables for one iteration, jump back to the loop header if loop needs to continue",
        operands = {
            --- A: target register; see FORNPREP for register layout
            { name = "a", type = {"register"}, description = "target register; see FORNPREP for register layout" },

            --- D: jump offset (-32768..32767)
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767)" },
        },
        size = 1,
    },

    --[=[
        FORGLOOP: adjust loop variables for one iteration of a generic for loop, jump back to the loop header if loop needs to continue
        loop variables are adjusted by calling generator(state, index) and expecting it to return a tuple that's copied to the user variables
        the first variable is then copied into index; generator/state are immutable, index isn't visible to user code
    ]=]
    [58] = {
        name = "FORGLOOP",
        opcode = 58,
        mode = "ad",
        aux = true,
        description = "adjust loop variables for one iteration of a generic for loop, jump back to the loop header if loop needs to continue\nloop variables are adjusted by calling generator(state, index) and expecting it to return a tuple that's copied to the user variables\nthe first variable is then copied into index; generator/state are immutable, index isn't visible to user code",
        operands = {
            --- A: target register; generic for loops assume a register layout [generator, state, index, variables...]
            { name = "a", type = {"register"}, description = "target register; generic for loops assume a register layout [generator, state, index, variables...]" },

            --- D: jump offset (-32768..32767)
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767)" },

            --- AUX: variable count (1..255) in the low 8 bits, high bit indicates whether to use ipairs-style traversal in the fast path
            { name = "aux", type = {"number"}, description = "variable count (1..255) in the low 8 bits, high bit indicates whether to use ipairs-style traversal in the fast path" },
        },
        size = 2,
    },

    --[=[
        FORGPREP_INEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_inext, and jump to FORGLOOP
    ]=]
    [59] = {
        name = "FORGPREP_INEXT",
        opcode = 59,
        mode = "abc",
        aux = false,
        description = "prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_inext, and jump to FORGLOOP",
        operands = {
            --- A: target register (see FORGLOOP for register layout)
            { name = "a", type = {"register"}, description = "target register (see FORGLOOP for register layout)" },
        },
        size = 1,
    },

    --[=[
        FASTCALL3: perform a fast call of a built-in function using 3 register arguments
    ]=]
    [60] = {
        name = "FASTCALL3",
        opcode = 60,
        mode = "abc",
        aux = true,
        description = "perform a fast call of a built-in function using 3 register arguments",
        operands = {
            --- A: builtin function id (see LuauBuiltinFunction)
            { name = "a", type = {"number"}, description = "builtin function id (see LuauBuiltinFunction)" },

            --- B: source argument register
            { name = "b", type = {"register"}, description = "source argument register" },

            --- C: jump offset to get to following CALL
            { name = "c", type = {"jump_offset"}, description = "jump offset to get to following CALL" },

            --- AUX: source register 2 in least-significant byte
            { name = "aux", type = {"register"}, description = "source register 2 in least-significant byte" },

            --- AUX: source register 3 in second least-significant byte
            { name = "aux", type = {"register"}, description = "source register 3 in second least-significant byte" },
        },
        size = 2,
    },

    --[=[
        FORGPREP_NEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_next, and jump to FORGLOOP
    ]=]
    [61] = {
        name = "FORGPREP_NEXT",
        opcode = 61,
        mode = "abc",
        aux = false,
        description = "prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_next, and jump to FORGLOOP",
        operands = {
            --- A: target register (see FORGLOOP for register layout)
            { name = "a", type = {"register"}, description = "target register (see FORGLOOP for register layout)" },
        },
        size = 1,
    },

    --[=[
        NATIVECALL: start executing new function in native code
        this is a pseudo-instruction that is never emitted by bytecode compiler, but can be constructed at runtime to accelerate native code dispatch
    ]=]
    [62] = {
        name = "NATIVECALL",
        opcode = 62,
        mode = "none",
        aux = false,
        description = "start executing new function in native code\nthis is a pseudo-instruction that is never emitted by bytecode compiler, but can be constructed at runtime to accelerate native code dispatch",
        operands = {},
        size = 1,
    },

    --[=[
        GETVARARGS: copy variables into the target register from vararg storage for current function
    ]=]
    [63] = {
        name = "GETVARARGS",
        opcode = 63,
        mode = "abc",
        aux = false,
        description = "copy variables into the target register from vararg storage for current function",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: variable count + 1, or 0 to copy all variables and adjust top (MULTRET)
            { name = "b", type = {"number"}, description = "variable count + 1, or 0 to copy all variables and adjust top (MULTRET)" },
        },
        size = 1,
    },

    --[=[
        DUPCLOSURE: create closure from a pre-created function object (reusing it unless environments diverge)
    ]=]
    [64] = {
        name = "DUPCLOSURE",
        opcode = 64,
        mode = "ad",
        aux = false,
        description = "create closure from a pre-created function object (reusing it unless environments diverge)",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- D: constant table index (0..32767)
            { name = "d", type = {"constant"}, description = "constant table index (0..32767)" },
        },
        size = 1,
    },

    --[=[
        PREPVARARGS: prepare stack for variadic functions so that GETVARARGS works correctly
    ]=]
    [65] = {
        name = "PREPVARARGS",
        opcode = 65,
        mode = "abc",
        aux = false,
        description = "prepare stack for variadic functions so that GETVARARGS works correctly",
        operands = {
            --- A: number of fixed arguments
            { name = "a", type = {"number"}, description = "number of fixed arguments" },
        },
        size = 1,
    },

    --[=[
        LOADKX: sets register to an entry from the constant table from the proto (number/string)
    ]=]
    [66] = {
        name = "LOADKX",
        opcode = 66,
        mode = "abc",
        aux = true,
        description = "sets register to an entry from the constant table from the proto (number/string)",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- AUX: constant table index
            { name = "aux", type = {"constant"}, description = "constant table index" },
        },
        size = 2,
    },

    --[=[
        JUMPX: jumps to the target offset; like JUMPBACK, supports interruption
    ]=]
    [67] = {
        name = "JUMPX",
        opcode = 67,
        mode = "e",
        aux = false,
        description = "jumps to the target offset; like JUMPBACK, supports interruption",
        operands = {
            --- E: jump offset (-2^23..2^23; 0 means "next instruction" aka "don't jump")
            { name = "e", type = {"jump_offset"}, description = "jump offset (-2^23..2^23; 0 means \"next instruction\" aka \"don't jump\")" },
        },
        size = 1,
    },

    --[=[
        FASTCALL: perform a fast call of a built-in function
        FASTCALL is followed by one of (GETIMPORT, MOVE, GETUPVAL) instructions and by CALL instruction
        This is necessary so that if FASTCALL can't perform the call inline, it can continue normal execution
        If FASTCALL *can* perform the call, it jumps over the instructions *and* over the next CALL
        Note that FASTCALL will read the actual call arguments, such as argument/result registers and counts, from the CALL instruction
    ]=]
    [68] = {
        name = "FASTCALL",
        opcode = 68,
        mode = "abc",
        aux = false,
        description = "perform a fast call of a built-in function\nFASTCALL is followed by one of (GETIMPORT, MOVE, GETUPVAL) instructions and by CALL instruction\nThis is necessary so that if FASTCALL can't perform the call inline, it can continue normal execution\nIf FASTCALL *can* perform the call, it jumps over the instructions *and* over the next CALL\nNote that FASTCALL will read the actual call arguments, such as argument/result registers and counts, from the CALL instruction",
        operands = {
            --- A: builtin function id (see LuauBuiltinFunction)
            { name = "a", type = {"number"}, description = "builtin function id (see LuauBuiltinFunction)" },

            --- C: jump offset to get to following CALL
            { name = "c", type = {"jump_offset"}, description = "jump offset to get to following CALL" },
        },
        size = 1,
    },

    --[=[
        COVERAGE: update coverage information stored in the instruction
        The hit count is incremented by VM every time the instruction is executed, and saturates at 2^23-1
    ]=]
    [69] = {
        name = "COVERAGE",
        opcode = 69,
        mode = "e",
        aux = false,
        description = "update coverage information stored in the instruction\nThe hit count is incremented by VM every time the instruction is executed, and saturates at 2^23-1",
        operands = {
            --- E: hit count for the instruction (0..2^23-1)
            { name = "e", type = {"number"}, description = "hit count for the instruction (0..2^23-1)" },
        },
        size = 1,
    },

    --[=[
        CAPTURE: capture a local or an upvalue as an upvalue into a newly created closure; only valid after NEWCLOSURE
    ]=]
    [70] = {
        name = "CAPTURE",
        opcode = 70,
        mode = "abc",
        aux = false,
        description = "capture a local or an upvalue as an upvalue into a newly created closure; only valid after NEWCLOSURE",
        operands = {
            --- A: capture type, see LuauCaptureType
            { name = "a", type = {"number"}, description = "capture type, see LuauCaptureType" },

            --- B: source register (for VAL/REF) or upvalue index (for UPVAL/UPREF)
            { name = "b", type = {"number","register",}, description = "source register (for VAL/REF) or upvalue index (for UPVAL/UPREF)" },
        },
        size = 1,
    },

    --[=[
        SUBRK: compute arithmetic operation between the constant and a source register and put the result into target register
    ]=]
    [71] = {
        name = "SUBRK",
        opcode = 71,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the constant and a source register and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: constant table index (0..255); must refer to a number
            { name = "b", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },

            --- C: source register
            { name = "c", type = {"register"}, description = "source register" },
        },
        size = 1,
    },

    --[=[
        DIVRK: compute arithmetic operation between the constant and a source register and put the result into target register
    ]=]
    [72] = {
        name = "DIVRK",
        opcode = 72,
        mode = "abc",
        aux = false,
        description = "compute arithmetic operation between the constant and a source register and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: constant table index (0..255); must refer to a number
            { name = "b", type = {"constant"}, description = "constant table index (0..255); must refer to a number" },

            --- C: source register
            { name = "c", type = {"register"}, description = "source register" },
        },
        size = 1,
    },

    --[=[
        FASTCALL1: perform a fast call of a built-in function using 1 register argument
    ]=]
    [73] = {
        name = "FASTCALL1",
        opcode = 73,
        mode = "abc",
        aux = false,
        description = "perform a fast call of a built-in function using 1 register argument",
        operands = {
            --- A: builtin function id (see LuauBuiltinFunction)
            { name = "a", type = {"number"}, description = "builtin function id (see LuauBuiltinFunction)" },

            --- B: source argument register
            { name = "b", type = {"register"}, description = "source argument register" },

            --- C: jump offset to get to following CALL
            { name = "c", type = {"jump_offset"}, description = "jump offset to get to following CALL" },
        },
        size = 1,
    },

    --[=[
        FASTCALL2: perform a fast call of a built-in function using 2 register arguments
    ]=]
    [74] = {
        name = "FASTCALL2",
        opcode = 74,
        mode = "abc",
        aux = true,
        description = "perform a fast call of a built-in function using 2 register arguments",
        operands = {
            --- A: builtin function id (see LuauBuiltinFunction)
            { name = "a", type = {"number"}, description = "builtin function id (see LuauBuiltinFunction)" },

            --- B: source argument register
            { name = "b", type = {"register"}, description = "source argument register" },

            --- C: jump offset to get to following CALL
            { name = "c", type = {"jump_offset"}, description = "jump offset to get to following CALL" },

            --- AUX: source register 2 in least-significant byte
            { name = "aux", type = {"register"}, description = "source register 2 in least-significant byte" },
        },
        size = 2,
    },

    --[=[
        FASTCALL2K: perform a fast call of a built-in function using 1 register argument and 1 constant argument
    ]=]
    [75] = {
        name = "FASTCALL2K",
        opcode = 75,
        mode = "abc",
        aux = true,
        description = "perform a fast call of a built-in function using 1 register argument and 1 constant argument",
        operands = {
            --- A: builtin function id (see LuauBuiltinFunction)
            { name = "a", type = {"number"}, description = "builtin function id (see LuauBuiltinFunction)" },

            --- B: source argument register
            { name = "b", type = {"register"}, description = "source argument register" },

            --- C: jump offset to get to following CALL
            { name = "c", type = {"jump_offset"}, description = "jump offset to get to following CALL" },

            --- AUX: constant index
            { name = "aux", type = {"constant"}, description = "constant index" },
        },
        size = 2,
    },

    --[=[
        FORGPREP: prepare loop variables for a generic for loop, jump to the loop backedge unconditionally
    ]=]
    [76] = {
        name = "FORGPREP",
        opcode = 76,
        mode = "ad",
        aux = false,
        description = "prepare loop variables for a generic for loop, jump to the loop backedge unconditionally",
        operands = {
            --- A: target register; generic for loops assume a register layout [generator, state, index, variables...]
            { name = "a", type = {"register"}, description = "target register; generic for loops assume a register layout [generator, state, index, variables...]" },

            --- D: jump offset (-32768..32767)
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767)" },
        },
        size = 1,
    },

    --[=[
        JUMPXEQKNIL: jumps to target offset if the comparison with constant is true (or false, see AUX)
    ]=]
    [77] = {
        name = "JUMPXEQKNIL",
        opcode = 77,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison with constant is true (or false, see AUX)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit
            { name = "aux", type = {"constant"}, description = "constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit" },
        },
        size = 2,
    },

    --[=[
        JUMPXEQKB: jumps to target offset if the comparison with constant is true (or false, see AUX)
    ]=]
    [78] = {
        name = "JUMPXEQKB",
        opcode = 78,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison with constant is true (or false, see AUX)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit
            { name = "aux", type = {"constant"}, description = "constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit" },
        },
        size = 2,
    },

    --[=[
        JUMPXEQKN: jumps to target offset if the comparison with constant is true (or false, see AUX)
    ]=]
    [79] = {
        name = "JUMPXEQKN",
        opcode = 79,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison with constant is true (or false, see AUX)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit
            { name = "aux", type = {"constant"}, description = "constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit" },
        },
        size = 2,
    },

    --[=[
        JUMPXEQKS: jumps to target offset if the comparison with constant is true (or false, see AUX)
    ]=]
    [80] = {
        name = "JUMPXEQKS",
        opcode = 80,
        mode = "ad",
        aux = true,
        description = "jumps to target offset if the comparison with constant is true (or false, see AUX)",
        operands = {
            --- A: source register 1
            { name = "a", type = {"register"}, description = "source register 1" },

            --- D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
            { name = "d", type = {"jump_offset"}, description = "jump offset (-32768..32767; 1 means \"next instruction\" aka \"don't jump\")" },

            --- AUX: constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit
            { name = "aux", type = {"constant"}, description = "constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit" },
        },
        size = 2,
    },

    --[=[
        IDIV: compute floor division between two source registers and put the result into target register
    ]=]
    [81] = {
        name = "IDIV",
        opcode = 81,
        mode = "abc",
        aux = false,
        description = "compute floor division between two source registers and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register 1
            { name = "b", type = {"register"}, description = "source register 1" },

            --- C: source register 2
            { name = "c", type = {"register"}, description = "source register 2" },
        },
        size = 1,
    },

    --[=[
        IDIVK: compute floor division between the source register and a constant and put the result into target register
    ]=]
    [82] = {
        name = "IDIVK",
        opcode = 82,
        mode = "abc",
        aux = false,
        description = "compute floor division between the source register and a constant and put the result into target register",
        operands = {
            --- A: target register
            { name = "a", type = {"register"}, description = "target register" },

            --- B: source register
            { name = "b", type = {"register"}, description = "source register" },

            --- C: constant table index (0..255)
            { name = "c", type = {"constant"}, description = "constant table index (0..255)" },
        },
        size = 1,
    },
};


return opcodes;